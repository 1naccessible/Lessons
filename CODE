int = вводит целочисленный тип данных.
Double(float тоже но редко) = вводит тип данных который поддерживает дробные числа с плавающей точкой
При делении например 10 на 4 и использовании типа данных int, дробная часть теряется и вместо
правильного ответа 2.5 выведет просто 2 так как дробная часть теряеться, а с типом данных double такого не происходит.

int MaxDaun(название переменной)=1 это тоже самое что int MaxDaun
							                            MaxDaun=1

метод main (точка входа в программу) в классе может быть только один

Название переменной не может начинаться с числа

public static void main (String args[]) =psvm + tab

Если написать:
int var1=10;
var1=20
System.out.println(var1)

то компелятор выведет на экран 20 потому что когда я задаю новое значение переменной,
то старое ее значение заменяется на новое

if(логическое выражение) - это оператор

Если в условие в if(логическое выражение) True то оператор выполняется, если False то оператор не выполняется.

if(lO < 11) System.out.println("lO меньше 11"); - строка отобразится

if(lO < 9) System.out.println("lO меньше 9"); - строка не отобразится

Меньше <
Больше >
Меньше или равно <=
Больше или равно >=
Равно ==
Неравно !=

Цикл for(инициализация; условие; итерация) пока логическое значение условия будет True, цикл будет испоняться.
Но когда  логическое значение условия будет False, цикл прекротится.
int count(рандомное название переменной)
for (int x=0; x<=100; x++){
            System.out.println("Loading  "+ x +"%");
            }
(count++)=(count+1)


блок кода это группа инструкций помещенных между закрывающей и открывающей фигурной скобкой, он становится
единой логической конструкцией и может быть использован
в любом месте программы как одиночная инструкция

counter или любая дургая переменная может быть счетчиком строк кода

можно обьявить переменную в блоке но тогда эта переменная будет видима и использоваться только в этом блоке

инкрементирование - это процесс увеличивающий значение переменной

декрементирование - это процесс уменьшающий значение переменной

Итерация - это один шаг интеграционного циклического процесса

-------------------------------------------------------------Ключевые слова, и для чего они служат--------------------

abstract - это модификатор отсутствия доступа в java, применимый к классам, методам, но не к переменным.

catch - Оператор catch позволяет определить блок кода, который будет выполняться, если в блоке try произойдет ошибка.

do-while - это цикл который будет выполнять блок ему принадлежащий до тех пор
 пока while(условия в данного цикла) будет True do{}while()

finally -

import -

new -

short - вводит целочисеньную переменную (16 бит)

this -

volatile -

assert -

char - вводит переменную для символов (16 бит) Значение 0 - 65536

double - вводит переменную которая поддерживает дробные числа с плавающей точкой (64 бит)

float - вводит переменную которая поддерживает дробные числа с плавающей точкой (32 бит)

instanceof -

package -

static -

throw -

while -

boolean - вводит тип данных который поддерживает только 2 значения true и false (1 бит)

class - опредедяет тип обьекта. Класс - это описание того какими свойствами и методами должен обладать обьект

else -

for - цикл for(инициализация; условие; итерация)

int - вводит целочисленный тип данных (32 бит)

private - обьявляет доступ члена как закрытый.
 Закрытые члены не видны другим классам и не один класс кроме того в котором он обьявлен,
 не может получить к ним доступ

strictfp -

throws -

break -

const -

enum -

goto -

interface -

protected -

super -

transient -

byte - вводит целочисленный тип данных (8 бит)

continue -

extends -

if - оператор условие если, if(условие) будет True оператор выполнит метод ему принадлежащий

long - вводит целочисленный тип данных (64 бит)

public - обьявляет доступ члена как общедоступный.
 Публичные члены видны всем классам и любой класс может получить к ним доступ

switch -

try - Оператор try позволяет определить блок кода,
 который будет проверяться на наличие ошибок во время его выполнения

case -

default -

final -

implements -

native -

return -

synchronized -

void -  Ключевое слово void означает, что метод main() не возвращает данных в программу,
 которая его вызвала.

----------------------------------------------------------------------------------------------------------------------


В Java все переменные, выражения и значения строго контролируются на типы данных

Встроенные типы данных Java делятся на ОО(Обьектно - ориентированные) и не ОО.

ОО типы данных определяются в классах.

В основу Java положенно 8 элементарных типов данных.(boolean, byte, short, int, long, float, double, char)
(что они означают смотреть выше)

Элементарные типы данных это означает что эти типы данных не являются обьектами, а обычными двоичными значениями

Таикие типы данных созданы в Java для увиличения эффективности программы, и все остальные типы данных базируются на них

В Java четко определен диапазон допустимых значений и область действия для типов данных

и все выше описанное на счет типов данных необходимо для переносимости программы

Метод sqrt в классе Math возвращает значение типа double, и сам тип данных double используется намного чаще чем float

Метод sqrt в классе Math возвращает корень квадратный из аргумента

метод sqrt определен в классе Math

перед написанием метода часто приходится писать класс которому они пренадлежат

в Java символы не являются 8 битными значениями

в Java для кодирования символов используется Unicode позволяющая представить символы всех  языков

переменной символьного типа (char) может быть присвоено значение в виде символа заключенного в одинарные кавычки ('x')

char x = 'y' при выводе переменной x будет выведенно присвоенное этой переменной символьное значение

над переменной символьного типа можно выполнять арифметические операции

переменную типа char можно инкрементировать

переменной типа char можно присвоить целочисленное значение и при выводе данного символьного значение
ему будет присвоен новый символ соответсвующий численому коду Unicode(ASC||) (alt + 80 = P)
первые 127 кодов и символов набора ASC|| принадлежат первым 127 значениям Unicode соответсвенно

boolean это логическое значение True & False, данный тип данных может применять одно из этих значений.

значенние переменной boolean может быть использовано для управления оператором if

метод print(), println() может выводить логические значения переменной boolean

в методе println() результат выполнения оператора сравнения тоже выводится логическим значением True & False
System.out.println("JA DAUN - " + (10<7))
выведеться при компеляции - JA DAUN - False

Литералы это постоянные значение который написал я сам и они используются программой
int x = 123 это литерал
Sout ("hello world") то что внутри кавычек внутри скобок это литерал
long y = 100_000_000L это литерал

Шестнадцатиричная система исчесления это 0 1 2 3 4 5 6 7 8 9 A B C D E F
A = 10; B = 11; C = 12; D = 13; E = 14; F = 15
для ее использование необходимо что бы знчаение одного из типов данных должен начинаться с 0x(Ноль и Икс)
Hex = OxFF; // соответствует десятичному числу 255

Восьмириная система исчесления это числа 0 1 2 3 4 5 6 7
для ее использование необходимо литерал одного из типов данных должен начинаться с 0(Ноль)
Oct = O11; // соответствует десятичному числу 9

Двоичная система исчесления это числа 0 1
для ее использование необходимо литерал одного из типов данных должен начинаться с 0b или B(Ноль + B or b)
Bit = 0b1100; // соответсвует десятичному числу 12
(int x = 0b1100;
        Sout(x)
            12)

Что бы указать в качестве литерала непечатный символ (например символ табуляции) или символ
имеющий специальное назначение (например одинарные ковычки) существуют управляющие
последовательности символов которые начинаются с обратной косой черты:
\' - одинарная ковычка
\" - двойная ковычка
\\ - обратная косая черта
\r - возврат коретки (возвращает в начало строки то что написано после него и стирает то что было до)
\t - символ горизонтальной табуляции (большой пробел при нажатии на таб)
\n - переход на новую строку
\f - переход на новую страницу
\b - возврат на однин символ(позицию) назада
\ddd - восьмеричная константа
\uxxx - шестнадцатиричная константа

пример присваевания переменной типа char символа табуляции и одинарной ковычки соответственно
char x = '\t'
char y = '\''

принцип работы строковых литералов смотреть в классе TableOfSymbol2_2

на протяжении всего срока действия переменной ее тип остается неизменным

динамическая инициализация переменной это когда при ее обьявлении и инициализации используется не константа
а любые выражения допустим арифметические

если обьявить переменную в блоке то она будет видна только коду и данным в этом блоке
но если обявить переменную в классе, то она будет видна всем блокам в программе
если обьявить переменную в блоке то она будет существовать до тех пор пока этот блок выполняется
а после конца выполнения блока ее значение теряется.

в состав арифметических операций помимо + - / * так же входять деление по модулю(остаток от деления) %,
 инкремент ++(+1) и дикремент --(-1)
существует постфиксанный и префиксный вариант декримента и инкремента (x--;--x;y++;--y)
Постфиксный вариант оличается от префексного тем что в префексной форме изменение значения операнда происходит
до его использование в выражении а в постфиксной наоборот

существуют так же логические операции сравнения
& - AND
| - OR
^ - Исключающие AND
! - NOT
работа вышеописанных показана в примере в классе LogicOperation

Укороченные логические операции И, ИЛИ

&& - AND
|| - OR
единственное отличие укороченных логических операций от обычных заключается в том,
что второй операнд вычесляется только тогда когда нужно.
Пример их работы показан в классе Scops

Однако если логика программы требует что бы второй операнд обязательно вычеслялся
стоит использовать обычные логические операции.
Пример того когда стоит это сделать показан в классе Scops2

= - это операция присваивания
int x, y, c
 x = y = c = 100 // присвоить переменным x, y, c value 100

Составные операции присваивания
+=
-=
*=
%=
/=
&=
|=
^=
How it works shown in class ComOpAs(CompositeOperationAssigment)

Для того что бы автоматически преобразовать тип данных из одного в другой нужно соблюдать две вещи:
1)Оба типа данных являются совместимыми
2)Диапазон допустимых значений у изначального типа должен быть меньше чем у целевого
How it works shown in class LtoDtoL

Работа приведения несовместиммых типов данных показана в классе CastDemo
при попытке изменить тип данных переменной значение которой выходит за диапазон целевого типа данных
происходит потеря данных.

ТАБЛИЦА ПРИОРИТЕТОВ ОПЕРАЦИЙ В JAVA
-------------------------------------------------------------------------------
НАИВЫСШИЙ
++(постфиксная) --(постфиксная)
++(префиксная) --(префиксная)           ~           !           +(унар)        -(унар)       (приведение типов)
*                /                   %
+                -
>>                  >>>                      <<
>                   >=                      <                   <=  instanceof
==                          !=
&
^
|
&&
||
?:
=                       op=
НАИНИЗШИЙ
------------------------------------------------------------------------------

Задача 2.2 решена в классе LogicOpTable

В выражениях можно спокойно использовать несколько типов данных если они совместимы с друг другом

в случе использования совместимых но разных типов данных в выражениях будет выполнено автоматическое
повышение типов.

Если использовать в выражении типы char, byte, short то сначала они все повышаются до типа int
затем если хоть один из операндов имеет значение типа long, то все они повышаютя до типа long, по такому же принципу
все значение потом повышаются до типа float, если хотя бы один из операндов относится к типу float,
а затем если хотя бы один из операндов относится к типу double, то в последствии все типы повышаются до типа double

повышение типов относится только к значениям участвующим в вычеслении выражения

Все что нужно знать о повышении типов данных это то что в выражении типы данных переменных повышаются до необходимого,
и должны после возвращаться до изначального типа, но иногда бывает что тип данных переменной остается повышенным
и после заверешения вычисления, то если логика программы требует конкретный тип данных у переменной
то стоит провести приведение типов за необходимостью.

How it works shown in class PromDemo

ctrl + alt + l = намного повышает удобочитаемость кода

круглые скобки повышают приоритет содержайщеся в них операции
так же повышают удобочитаемость выражений и не замедляют процесс компиляции программы если они избыточны
они так же могут прояснять порядок вычесления в выражении для меня и для тех кто будет читать код в дальнейшем

Почему в Java строго определены диапазоны допустимых значений и области действия простых типов?
потому что у каждого типа есть выделенный компилятором обьем памяти для хранения значений.
Таким образом тип boolean не может хранить значения типа char. тип int не может хранить
значение типа char или boolean или типа long если значение данного типа выходит за диапазон допустимых значений
типа int

класс KeyBIn(растолкование того что там написано)
метод main начинается со строк кода - public static void main(String[] args)
                                              throws java.io.IOException {}

throws java.io.IOException {}   это оператор который нужен для обработки ошибок которые могут возникать
в процессе ввода данных в консоль с клаввиатуры

существует вид консольного ввода который называется Чтение с клавиатуры

для чтения символа с клавиатуры достаточно вызвать метод System.in.read()
где System.in - обьект ввода (с клавиатуры) дополняющий обьект вывода System.out

Метод read() ожидает нажатие клавиши после чего возвращает результат.

Возвращаемый им символ представлен целочисленым значением
по этому требуется явное его приведение к типу char

для передачи программе любого введеного с клавиатуры символа
нужно после ввода нажать клавишу Enter

полная форма оператора If -
if() оператор
else - условный оператор
else будет выполняться если оператор if не выполнился ввиду невыполненного условия внутри скобок
else подвязан к ближайшему if и не используется без него
если else прописан вне блока то он будет искать ближайший if() который тоже находится вне блока и выше else
how it works shown in class Guess

многоступенчетая конструкция if-else-if
оператор if который входит в другой оператор if или else называется вложенным
how it works shown in class IfElseIf

оператор switch - оператор выбора для многовариантной проверки. Для этого может использоваться и if-else-if
но иногда легче и лучше будет использовать оператор switch. общий вид данного оператора:

switch (выражение) {
case константа1:
последовательность операторов
break;

case константа2:
последовательность операторов
break;

case константа3:
последовательность операторов
break;

default:
последовательность операторов

значение выражения в операторе последовательно сравнивается с константами заданными в ряде
если будет обнаруженно совпадение выполняется последовательность операторов.
How it works shown in SwitchDemo

default выполняется в случае если совпадений не обнаруженно
ветвь default не является обезательной так как если ее не написать
и совпадений не обнаружется, то ничего не будет выполнятся вовсе

так же оператор break может отсутсвовать
при выполнении оператора break оператор switch завершает работу и передает действия следующму оператору
если оператор break отсутвует и с одним из операторов case (константой ему пренадлежащей) найдется совпадение
то выполнятся все последующие после него операторы case
даже если совпадения с их констанатами не было обнаруженно, после чего оператор switch
завершит свою работу.
how it works shown in class NoBreakSwitchDemo

также может быть оператор switch вложенный в оператор case внешнего оператора switch
how it works shown in class SwitchInSwitch

class Help это справачник по операторам

как поменять переменные местами показано в классе TwoNumbers

go to see class SqrtRoot в котором показано использование Math.sqrt в цикле

для управления циклом for можно использовать 2 и более переменных
how it works shown in class Comma

условным выражением в цикле for может быть абсолютно любое выражение которое дает результат True or False
так же циклом можно управлять с помощью конвольного ввода - чтение с клавиатуры
how it may works shown in class ForTest

в цикле for можно вообще пропустить любую часть определения цикла фор
то есть либо иницализацию либо условие либо итерацию либо комбинацию из двух определений
либо вообще ничего из этого не указывать и сделать цикл бесконечным for(;;)
для завершение любого и даже бесконечного цикла можно использовать оператор - break;
how it works shown in class Empty

допускается осталять цикл for и любые другие циклы без тела
это иногда бывает полезным
how it can use shown in class Empty2

если обьявить переменную прямо в цикле то ее действие за пределами цикла заканчивается
Переменная не будет выдна ни одному оператору кроме тех котоые пристувуют в том же цикле
в котором она обьявленна

цикл while
while (условие) оператор или {последовательность операторов}
цикл будет выполнятся до тех пор пока условаие = true
how it works shown in WhileDemo

цикл do-while
его отличие от циклов for и while в том что в нем условие проверяется после выполнение кода,
это значит что в отличии от for и while цикл do-while выполнится хотя бы 1 раз.
do{
оператор или операторы
}while(условие)
выполняется пока условное выражение истинно
how it works shown in class DWDemo

c помощью цикла do-while можно усовершенствовать программу в классах например Guess или Help
где цикл не будет заканчиваться после ввода с клавиатуры одного символа.

что бы убрать баг с тем что при вводе символа и нажатия ENTER блок кода в цикле
do-while повторялся дважды или более раз достаточно в цикл do-while добавить
еще один цикл do while:
char ignore;
do{
 ignore = (char) System.in.read()
}while(ignore!='\n')

Усовершенствовал программы в классах Help и Guess

оператор break; нужен для немедленного завершения любого интегрированного цикла в котором он находится
 пример:
 for(int x=0;;x++){
 If(x==100) break;
}
как только x == 100 цикл завершится. и так работает с любым циклом и абсолютно любым логическим условием

полная форма оператора break метка;
метка это имя которое обозначает блок кода
используя данный вариант break можно выйти
и прервать несколько блоков кода вложенных в цикли или в оператор switch
блоку кода можно дать метку по которой перейдет оператор break;
и прервет выполнение данного блока или нескольких блоков после чего
 выполнение программы начнется с конца остановленного блока или структуры блоков
 что бы дать имя блоку или оператору которому пренадлежит блок достаточно написать
 любой индетификатор с двоиточием в конце
 если поставить метку перед открывающей фигурной скобкой
 то управление передастся в конец тела внешнего цикла и сам цикл продолжится
 в операторе break нельзя использовать метку не определенную в охватывающем его цикле
 how it works shown in class BreakLable

оператор continue пропускает оставшийся невыполненный код в цикле и начинает новую итерацию данного цикла
how it works shown in class ContDemo

в цикле do-while and while оператор continue передает управление непосредственно условному выраженнию,
после чего цикл продолжается

как и в операторе break так и в операторе continue может пристутсвовать метка
обозначающая тот цикл который должен продолжить выполнение
how it works shown in class ContLabel
как  показанно в классе ContLabel
при выполнении оператора continue оставшиеся итерации внутреннего цикла пропускаются
и управление передается внешнему циклу

в одной итерации внешнего цикла for вложенный цикл for выполняет необходимое количество итераций
 вплоть до бесконечности
 How it works shown in class ForInFor

---------------------------------------Chapter 4-------------------------------------------------------------------

класс это описание в соответсвии с которым должны создаваться обьекты
обьекты это экземпляры классов
данные - как членны класса называются переменными экземпляра
определяя класс, обьявляется его конкретный вид и поведение, для этого
указываются содержащиеся в нем переменные экземпляра и методы опирируещие ими
Класс может содержать как только переменные экземпляра так и только методы
но большенство классов должны содержат и данные и методы

Порядок создания обьекта:
Название класса название переменной = new Конструктор()
в левой части обьявляется ссылка на обьект
в правой части с помощью оператора new выделяется память для нового обьекта
ссылка на обьект присвается переменной
Конструток имеет такое же имя что и класс в котором он обьявлен.

что бы не нарушать структурированность кода в классе стоит содержать данные и методы
относящиеся к одной логической сущности (Если в классе данные о номерах телефонов пациентов
то это класс не должен содержать данные о погоде или данные которые не имеют отношение к деллу)

метод main() указывается в классе только в том случае если с него начинается выполнение программы

когда создается экземпляр класса он хранит в себе копию всех переменных экземпляра
для обращенния к этим переменным используется точечная нотация
обьект.член
точечную нотацию можно так же использовать для обращения к методам экземпляра
если переменной fuelcap обьекта minivan нужно присвоить значение 16 то это делается так
minivan.fuelcap  = 16
принцип создание обьекта, переменных экземпляра инкапсултрованных в класс и сипользование их
показанно в классе Vehicle
 данные из обьекта minivan отличаются от данных из обьекта sportcar
 потому что они использую копии переменных экземпляра
 а значит что и значение у переменных экземпляра для каждого обьекта могут быть разные

общий синтаксис обьявления метода в классе
возвращаемый_тип имя(список параметров) {
            //тело метода
}
Возвращаемый тип - это любой допустимый тип данных возвращаемый методом
в том числе может быть и тип класса который я создал сам.
Если метод ничего не возвращает для него указывается тип void
Имя - это может быть любой идентификатор кроме зарезервированных или ключвых слов
или слова не приводящие к конфликтам в области действия метода
Список параметров - это последовательность разделенных запятыми параметрова для которых указывается тип и имя
параметры это переменные которые получаеют значение передаваемые им в виде аргумента при вызове метода
если у метода параметры отсутствуют то список параметров остается пустым
How it works shown in class Vehicle

в теле метода при обращение к переменным не стоит ипользовать точечную нотацию и указывать обьект.
Так как метод вызывается для данного обьекта
и берет данные относящиеся к тому обьекту для которого и был вызван метод

если для метода указан тип void это означает то
что метод не возвращает никаких данных части программы для котороой он был вызван

организовать немедленое завершение метода типа void и возврат из него можно с помощью формы оператора return:
return;
при выполнении оператора return управление передается вызывающей части программы
а оставшийся в методе код игнорируется
так же в одном методе допускается использовать несколько операторов return
необходимость в них возникает в том случае если  в метод организованно несколько ветвей выполнения
how it works shown in class VoidReturn

если метод должен возвращать некое значение то нужно задать тип данных который он должен возвращать
и форму оператора return:
return значение;
в таком случае метод будет возвращать значение типа который указан перед названием метода и передавать его той
части программы которая его вызвала
данную форму оператора return можно использовать только в тех методах тип которых отличен от типа void
how it works shown in class Vehicle

методу можно передать один или несколько аргументов(значений)
переменная получающая аргумент называется параметром
параметры метода обьявляются в скобках после его имени
how it works shown in class ChkNum

Method with several parametrs shown in class Factor

Синтаксис для нескольких параметров в методе:
тип данных имя(int x, double y, char c)

Updated class Help

Конструктор ипользуется для создания первоначальных значений переменных экземпляра
или для инициализации обьекта если в конструкторе указаны параметры
Его имя совпадает с именем класса в которм он находится
а его синтаксис схож с синтаксисом метода
он используется для создания и инициализации обьекта
если он не задан используется конструктор по умолчанию
в котором переменные всех типов данных имет базовое значение
конструктор не иммеет возвращаемого типа данных
How it works shown in class Construkt

параметризированный конструктор по работе схож с параметризированным методом
    how it works shown in class ParamConstrukt

использованиe параметризированного констурктора показано в классе NewVehicle

Порядок создания обьекта:
Название класса название переменной = new Конструктор(аргументы)
в левой части обьявляется ссылка на обьект
в правой части с помощью оператора new выделяется память для нового обьекта
и ссылка присвается переменной
Конструток имеет такое же имя что и класс в котором он обьявлен.
аргументы это значение которые будут переданны в параметры конструктора

Сборка мусора в java это процесс который проход без участия програмиста
и суть его работы в том что если для выполенния программы требуется оперативная память а ее не хватает
и существуют обьекты которые более программа не использует, то она просто удаляет из оперативной памяти
эти обьекты тем самым освобождая память

метод finalize() вызывается перед удалением из памяти обьекта и так как бы гарантирует его безопасное закрытие
но предсказать когда Java удалит обьект из памяти невозможно а значит этого может и вовсе по ходу
программы не произойти. Значит программа должна не зависить от этого метода.
данный метод достаточно определить в классе для того что бы он мог работать
синтаксис данного метода:
protected void finalize(){
   //код метода завершения
}
Ключиевое слово protected - спецификатор предотвращающий доступ к методу за пределами его класса

пример работы метода finalize() shown in class FDemo

оператор this ссылается на обьект для которого был вызван метод
следовательно this.имя_переменной это ссылка на копию имя_переменной
How operator this can be usable shown in class Pwr

Класс - это абстрактное логическое описание формы и поведения обьекта
Обьект - это вещественный экземпляр класса
оператор new - выделяет память для обьекта и выполняет его инициализацию используя конструктор
this -  означает ссылку на обьект для которого вызывается метод. Эта ссылка автоматически передается методу

--------------------------------------Chapter 5-----------------------------------------------------------------

Массив - это совокупность однотипных данных
Массивы реализованны в виде обьектов
Массивы бывают одномерными и многомерными
Массив позволяет организовать данные таким образом что бы ими было проще манипулировать
Одномерный массив - это список связанных однотипных переменных
синтаксис обьвляения массива
тип имя_переменной[] =new тип [размер]
пример:
int sample[]= new int [10]
обьявление массива работает так же как обьявление обьекта
доступ к отдельному элементу масива осуществляется с помощью индексов
индексация масива начинается с 0
то есть если в массиве хранится 10 элементов то они принадлежат индексам от 0 до 9
вызывая десятый элемент массива нужно указать индекс [9]
демонстрация одномерного массива в классе ArrayDemo

Нахождение максимального и минимального числа в масиве с 10 элементами
показано в класс MinMax
пример инициализации массива 10 переменными показано в классе MinMax2

границы массива если размерность указана строго саблюдаются
в случае выхода индекса за верхнюю или нижнюю границу масива будет выведенно сообщение об ошибке

алгоритм пузырьковой сортировки не очень эффективен
но он подходит для сортировки небольших массивов
в данном алгоритме меньшие значение сдвигаются к одному краю масива
а большее к другому
пример инициализации массива так же показан в классе Bubble
алгоритм пузырьковой сортировки показан в классе Bubble

Многомерные массивы представляют собой массивы масивов

Двумерные массивы - это самые простые массивы среди многомерных
синтаксис обьявление двумерного целочисленого массива с размером 10*20:
int table[][]=new table[10][20]
где 10 - количество одномерных масивов(линий)
а 20 количество элементов в одном одномерном массиве(линии)
демонстрация использования двумерного массива и заполнение его полей в классе Twod

при выделении памяти для многомерно массива достточно указать крайний слева размер
а память для массива другого измерения можно выделить отдельно:
int demo[][]=new int[4][]
demo[0]=new int[2]
demo[1]=new int[2]
demo[2]=new int[1]
demo[3]=new int[5]
как показано выше это дает установить разную длинну(размер) масива по каждому индексу
не рекомендуется их использовать
но есть случаи когда нерегулярные массивы могут существенно повысить эффективность программы
если допустим требуется создать большой двумерный массив в котором используются не все элементы
пример использования такого способа обьявления массивов показанно в классе Ragged

общая форма обьявления многомерного массива больше двух измерений
int name[][]...[]= int[размер 1][размер 2]...[размер N]
exemple:
int name[][][]=new name[4][10][3]

Синтаксис инициализации двумерного массива
type name[][]={
{var, var, var, ...var}     Индекс массива 0
{var, var, var, ...var}     Индекс массива 1
{var, var, var, ...var}//линии элементов(массивы)   Индекс массива 2
.
.
.
{var, var, var, ...var}//каждая линия элементов принадлежит индексу Индекс массива N
};
пример инициализации двумерного массива в классе Squares

альтернативный синтаксис обьявления массива:

int name[] = new int[10]
int[] name = new int[10]
эти два примера выше абсолютно равнозначны

int name[][] = new int[10][20]
int[][] name = new int[10][20]
эти два примера выше абсолютно равнозначны

альтернативная форма обьявления массива удобна когда нужно обьявить несколько однотипных массивов подряд
int nums[], nums1[], nums2[] //создать 3 массива
int[] nums, nums2, nums3// точно так же создаст 3 массива

так же альтернативное обьявление массиво очень удобно
когда в качестве типа возвращаемого методом нужно указать массив
например:
int[] methed(){
.......
}
выше обьявлен метод method() возвращающий массив типа int

при присваивании двум переменным ссылки на один массив копия массива не создается
и в этом плане массивы ничем не отличаются от обьектов
просто две переменные ссылаются на один и тот же массив
пример присваивания 2 переменным ссылки на один и тот же массив показан в классе AssignAref

В каждом массиве содержится переменная экземпляра length
length содержит в себе количество элементов которые может содержать массив,
и следует принять во внимае то что переменная экземпляра length не содержит в себе
фактическое количество эллементов в массиве, но только максимально возможное количество элементов в нем
это может упростить задачу тем что не прийдется слидить за тем сколько элементов в массиве самому
и это полезно при выполнении циклических операций с массивом.
в двумерном массиве она показывает только количество массивов в нем
для кадого одномерного массива из двумерного массива количество элементов
нужно проверять отдельно по индексу
Пример использования переменной экземпляра length показанно в классе LengthDemo

очередь - это тип организации элементов по типу первым пришел первым пришел - первым обслужен
весь процесс создания классов очерди показан в классах QDoub and Queue

for-each - разновидность цикла for
синтаксис:
for (тип итерационная_переменная: коллекция) блок операторов
конктретный тип итерационной переменной в которой поочередно сохраняются
все элеметы набора данных то есть колекции(масив)
тип итерационной переменной должен совпадать или хотя бы быть совместимым
с типом массива из которого эта переменная сохраняет значение элементов массива

for-each цикл нужен для обработки каждого эллемета массива
это полезно например при подсчете суммы всех элементов массива
для чего нужно обращаться к каждому его элементу
так же не обязательно обрабатывать все элементы масива
так как цикл можно остановить с помощью оператора break
пример работы цикла for-each показано в классе ForEachDemo

итерационная переменная в этом цикле обеспечивает только чтение массива
и не предназначенна для записи новых значений в элементы массива
как это работает показано в классе NoChange

при использовании цикла for-each по отношению к двумерному массиву(масиву масивов)
итерационная переменная сохраняет в себе ссылку на очередной одномерный массив
для извлечения элементов масивов двумерного масива используется
вложенный цикл for
как это делать показанно в классе ForEach2

расширенный оператор for-each перебирает все элементы масива
и используется в очень многих алгоритмах
например организация поиска элемента колекции и это показанно в классе Search

символьные строки в Java это обьекты
Обьект типа String определяет символьную строку и поддерживает операции над ней
При создании строкового литерала генериркется обьект типа String
System.out.println("In java symbol lines - objects")
Наличие в примере выше строкового литера "In java symbol lines - objects"
автоматичнски приводит к созданию обьектf типа String

Обьекты типа String создаются так же как и другие обьекты
ниже приведен пример синтаксиса создания обьекта типа String:
String name = new String("TEXT")
String name2 = new String(name)
обьект name2 теперь содержит в себе строку обьекта name
String name3 = "SOME TEXT" - пример инициализации обьекта типа String символьной строкой

Создав обьект типа String можно использовать его везде где
допускается возможность использования символьной строки
допустим передать его в качестве параметра методу println()
example shown in class StringDemo

класс String содержит ряд методов для манипуляции строками:

boolean equals (str) - возвращает логическое значение true
если текущая строка содержит то же количество символов что и параметр str

int length() - возвращает длинну строки

char charAt (index) - возвращает символ занимающий в строке позицию указываемую параметром index

int compareTo(String str) - лексикографически стравнивает символы строк и если сравнимаемый с другой строкой
обьект типа String меньше
метод compareTo(String str) выводит -1, если больше выводит 1, если равны выводит 0

int indexOf(String str) - индекс первого вхождения символа, или с какого индекса впервые в строку вошло слово

int lastIndexOf(String str) - индекс последнего вхождения символа,
или с какого индекса в последний раз в строку вошло слово.
применение каждого из этих методов показано в классе StrOps

подобно другим типам данных строки можно обьеденять в масивы строк
показано в классе StringArrays

Обьекты типа String являются неизменяемыми обьектами
так если потребуется видоизменить уже существующую строку в обьекте типа String
нужно создавать новую строку содержащую все необходимые изменения
следует иметь ввиду что содержимое ссылочных переменных типа String может менятся
приводя к тому что переменная будет ссылаться на другой обьект
но содержимое самих обьектов типа String остается неизменным после того как его создали

еще один способ обработки класса String - метод substring()
substring() -  возвращает новую строку которая сожержит часть вызывающей строки
в итоге создается новый строковой обьект содержащий выбранную подстроку
а исходная строка не меняется и выходит соблюдается принцип постоянства строк
синтаксис substring():
String substring(int начальный_индекс, int конечный_индекс)
начальный индекс - обозначает начало извлекаемой подстроки
конечный индекс - обозначает конец извлекаемой подстроки
как применять данный метод показанно в классе SubStr

обьекты типа стринг подходят для управления оператором типа switch
how it work shown in class StrSwitch
но без особой надобности это делать не нужно
так как это может снижать эффективность программы

String[] args - содержит в себе массив аругементов командной строки
для того что бы обратится к массиву обьектов типа String
how it works in class CLDemo
для того что бы передать аргументы массиву обьектов типа String
нужно зайти в "Edit Configurations" и там вібрать класс в котором буду задавать парметры
и задать параметры
How it works shown in class Phone

------------------------удалить за ненадобностью---------------------------------------------------------------------
Поразрядные(побитовые) операции это те операции которые используют для
проверки, установки и сдвига отдельных разрядов чисел
пример поразрядных операций:
& - поразрядное И
| - поразрядное ИЛИ
^  - поразрядное исключающее ИЛИ
~ - дополнение до 1(унарная операция НЕ(NOT))
       X=         Y=          X & Y           X | Y           X ^ Y            ~X
       0          0             0               0               0              1
       1          0             0               1               1              0
       0          1             0               1               1              1
       1          1             1               1               0              0
----------------------------------------------------------------------------------------------------------------------

оператор ? называется тернарным так как он обрабатывает 3 операнда
и записываеться он в следующей общей форме:
выражение1 ? выражение2 : выражение3
выражение1 - это логическое выражение в результате дающее значение типа boolean
выражение2 и выражение3 могут быть любого типа кроме void и обязательно должны совпадать
выражение2 вычесляется и его результат становится конечным если выражение1 дало логическое значение true
выражение3 вычесляется и его результат становится конечным если выражение1 дало логическое значение false
оператор ? заменяет оператор if-else cледующего вида:
if(условие)
переменная = выражение1;
else
переменная = выражение2;
пример использование данного оператора показан в классах AbsVar and NoZeroDiv

если нужно отсортировать массив с помощью метода sort находящегося в классе Arrays
Arrays.sort(array)
сортируеться он от наименьшего к наибольшему значению слева направо
how it works shown in class ClassArraysSort

модификатор доступа к членам класса - private, public
public - допускает доступ к члену класса из любой части программы
если модификатор доступа не указан то используется модификатор доступа по умолчанию(по сути, public)
private - ограничивает доступ к членам класса из других классов
доступ к членам класса c модификатором доступа privat имеют только члены класса находящиеся
с этим членом класса в одном классе
для обращение к приватным членам класса из вне того класа в котором они обьевлены
возможно только если обращаться к публичному методу класса который обращается к этой приватной переменной
how it works shown in class MyClass and FailSoftArray

улучшил класс Queue добавив массиву q и переменным getloc и putloc модификатор доступа private
для того что бы из вне этого класса этим переменным невозможно было изменить значения
и так же не было доступа к элементам массива которые теперь так же нельзя изменить из вне класса в котором он обьявлен

параметрами методов могут быть так же и обьекты
how it works shown in class Block

существует возмжоность в качестве параметра для метода указывать обьект
как это работает показано в классе Block

при передаче простых типов данных методам, значения аргумента не могут быть измененны
how it works shown in class NewNoChange

Но если методу передается обьект то и аргумент и параметр метода ссылаються на один и тот же обьект
и если метод изменениет что-то в обьекте то и обьект используемый в качестве аргумента потерпит изменение
How it works shown in class CallBeReff

Методы могут возвращать данные любых типов включая обьекты
как это работает показанно в классах Err and ErrorMsg.

Несколько методов одного класса могут иметь одно и тоже имя и отличаться только лиш набором парамтров
Для того что бы перегрузить метод достаточно обьявить его новый вариант соблюдая хотя бы одно
из двух условий:
тип и/или число параметров в каждом из перегруженных методов должны отличаться
how it works Shown in class Overload

тип возвращаемого значение не учитываеться при перегрузке метода
следовательно обьявить два варианта метода измнив просто взвращаемый тиа данных не выйдет

автоматическое приведение типов данных распростряняется и на типы данных параметров
автоматическое преобразование типов выполняеться лишь в том случе если нет прямого соответсвия
типов параметров и аргументов
how it works shown in class Overload2

Перегрузка методов упрощает задачу посталенную перед програмистом когда требуеться
выполняет одинаковые операции над разными типами данных

метод abs() в классе Math вычесляет аобсолюное значение аргумента не в зависимости от того какой тип
данных у самого аргумента. java сама выбирает тип операции abs подходящий для вычесление абсолютного
значение аргумента. Это говорит о том что этот метод так же как и другие методы Java поддерживает перегрузку

Не стоит использовать одно и тоже имя для методов которые не связаны друг с другом

Термин Сигнатура обозначает имя метода и список его параметров
следовательно два метода не могут иметь абсолютно одинаковые сигнатуры
Сигнатура не включает в себя тип данных возвращаемый методом
так так тип данных не учитывается при принятии решения о перегрузке

Как и методы конструкторы тоже могут перегружаться
Показанно в классe OverCons
конкретный вариант конструктора для метода выбираеться Java на основании аргументов заданых в обьекте

Перегрузка конструкторов чаще всего используеться для того что бы инициализировать
один обьект на основании другого
Зачастую удобно иметь конструктор создающий копию обьекта
How it works shown in class Summation

Улучшил класс Queue который создан на основе класса Queue2 добавив перегруженые конструкторы

Рекурсия это процесс когда метод вызывает самого себя. Такой метод называется рекурсивным
Рекурсивный метод содержит оператор который вызывает метод в котором он же и находится.
Когда метод вызывает самого себя, то в системном стеке расприделяется память для
новых локальных переменных и параметров, и код метода выполняеться
с этими новыми параметрами и переменными с самого начала
How it works shown in class Factorial

ключевое слово static определяет член класса для обращение к которому не нужен обьект
Члены класса обьявленные как static называються статическими
для обращения к такому члену класса за пределами его класса не нужно создавать обьект
для обрачение к статическим членам класса нужно использоывать точечную нотацию
и вместо имени обьекта для обращения к члену класса нужно указать имя класса
которому пренадлежит данный член класса
Так если потребуеться присвоить статической переменной val находящейся в классе Timer значение 10
то синтаксис будет таков:
Timer.val = 10
Анологично этой форме вызова вызываются и статические методы
Переменые static являются глобальными
Это значит что при создании обьектов класса где находиться статичсекая переменная
в них не сохраняеться копия данной переменной, а все обьектысовместно пользуются
одной и той же переменной
Пример отличий статичсекой и обычной переменной и их использования
показан в классе StaticDemo

В статических методах есть ряд особенностей:
1.В методе типа статик допускается вызов только других статических методов
2.Для статического метода доступными оказываются только другие данные статического типа
3.В статическом методе должна отсутсвовать ссылка this.
пример статичсекого метода показан в классах StaticMeth, StaticError

Статический блок - это блок это блок кода который будет выполнятся при первой загрузке клсса
еще до того как класс будет импользован для каких нибудь других целей
это может быть полезно для действий которые необходимо выполнить в самом начале
еще до выполнения кода в классе
пример применения статического блока показан в классе StaticBlock

Быстрая сортировка - еще один метод сортировки который немного быстрей пузырьковой
 но сложнее чем она почти в 2 раза QuickSort

Вложенный класс - это класс вложенный в другой класс,
и он не может существовать без класса в который он вложен
такой класс имеет доступ ко всем переменным и методам из внешнего класса
и может обращаться к ним непосредственно как и все нестатические членны внешнего класса
но не наоборот
Область действия вложенного класса ограничена его внешним классом
Внутренний класс используеться в основном для придоставления ряда услуг внешнему классу
для обращения метода из внешнего класса к внутреннему нужно создать в внешнем методе
обьект вложенного класса
внутренний класс не может быть безымянным
Пример вложенного класса показан в классе Outer

Существуют методы с переменным числом аргументов (методы переменной арности)
В методах данного типа список параметров имеет не фиксированную
а переменную длинну, что позваляет методам принимать произвольное число аргументов
Методы данного типа могут быть полезны когда неизвестно количество аргументов
которые ему необходимо принять
Пример использования метода с переменным числом аргументов показанно в классе VarArgs
что бы обьявить метод со списком аргуметов переменной длинны
нужно импользовать следующий синтаксис:
тип_данных ... имя_переменной
Пример:
int ... a
это так же обьявляет параметр 'а' массивом хранящий элементы типа int
при вызове метода может указываться переменное число аргументов которые будут записываться
в массив аргументов 'a'
массив аргуметов переменной длинны называеться параметром - varargs
Если вызывать метод не указывая аргуметы то массив будет содержать 0 элементов
массив аргументов переменной длинны должен быть последним параметром метода если помимо него
метод принимает аргументы других типов
и указываться массив с переменным числом аргументов может только 1 раз
Пример:
int doIt(int a, int b, boolean trFs,int ... c)
данный пример обьявления метода впослне допустим
Использование массива аргументов переменной длинны показано в классе VarArgs2

Методы с параметром varargs можно перегружать так же как и другие методы
есть два способа перегрузки метода с переменным числом аргументов.
1 - это изменить тип параметра varargs так как это массив который имеет тип
2 - это добавить дополнительные параметры
Пример перегрузки методов с переменным числом аргументов показанно в классе VarArgs3

При перегрузке метода с переменным числом аргументов иногда может приводить
к ошибке неоприделенности - когда компелятор не способен выбрать между двумя методами
которые способны принять один и тот же аргумент
Во избежание этого рекомендуеться давать методам разные имена и отказаться от перегрузки
Пример возникновения данной ошибки показан в классе VarArgs4

Задания к теме 6:
1. Нет так как доступ к членам класса c модификатором доступа private имеют только
члены того же класса что и член класса с модификатором доступа private
2. Модификатор доступа должен предшевствовать обьявлению члена класса
3. Решение в классе Steck
4. Решение в классе Swap
5. Нет, так как именив только возвращаемый тип данных метод перегрузить не получится
6. Решение в классе Recursion6
7. Обьявить такую переменную можно с помощью ключевого слова static
8. Статический блок может понадобиться в случае если нужно что то прогрузить или выполнить перед началом
запуска кода программы
9. Внутрений класс это класс вложенный в другой класс
он призван для того что бы расширить возможности или добавить функционал к внешнему классу
его область действия ограничена внешним классом, переменные и методы во внутренем классе недоступны внешнему
но не наоборот
10. privat - так как член класса с таким модификатором доступа доступен только другим членам его же класса
11. имя метода и список его параметров составляют собой сгнатуру метода
12. Если методу передаеться значение типа int, то в этом случае используеться передача параметра по значению
13. вызов метода с переменным числом аргументов и суммирование этих аргументов в классе SumArgs
14. Да, но не стоит этого делать из за возможности столкнуться с ошибкой неопределенности
15. Пример перегрузки метода с переменным числом аргументов демонстрирующий ошибку неопределенности
показан в классе MethError

------------------------------------------------Chapter 7------------------------------------------------------
Супер класс - это класс который наследуют подклассы
подкласс включает в себя все члены суперкласса но не наоборот
для каждого создаваемого под класса можно указать только один суперкласс
подкласс не может наследоваться от нескольких суперклассов
подкласс может быть унаследован от другого подкласса - многоуровневая иерархия
так же если класс являеться суперклассом, его членами так же можно пользоваться и обращаться
к ним через обьект данного суперкласса
класс не может быть суперклассом для самого себя
для того что бы класс унаследовался от другого супер класса достаточно добавить
ключевое слово extends перед именем суперкласса и после имени подкласса:
class TEST1 extends TEST{}
В основном суперкласс содержит в себе общие для множества обьектов свойства
а подкласс добавляет особенные для каждого из обьектов атрибуты и свойства исходя из конкретной необходимости
Пример созания подклассов  суперклассов показан в классе TwoDShape

подкласс не наследует закрытые члены суперкласса
подкласс не может обращаться к закрытым членам суперкласса
для обращение к закрытым членам суперклассов нужно создавать методы доступа
которые способны обращаться к членам суперкласса с модификатором доступа (private)
пример создания методов доступа к закрытым членам суперкласса показан в классе TwoDShape2

Если в подклассе и суперклассе создать конструкторы, то создавая обьект подкласса
выполняться для этого обьекта будут 2 конструктора как и подкласса так и суперкласса
при создании конструктора только в подклассе, обьект подкласса будет использовать
явно обьявленный конструктор подкласса и конструктор по умолчанию супер класса
при создании конструктора в суперклассе и под классе, для родительской части
обьекта подкласса будет использован конструктор суперкласса, а для остальной его части
будет использоваься конструктор подкласса
использование конструктора подкласса показанов классе TwoDShapeCons

Для вызова конструктора суперкласса требуеться следующая общая форма ключевого слова super:
super(список_параметров)
super() всегда должен быть первым оператором в теле конструктора подкласса
example shown in class TwoDShapeSuper

Вызов super() позволяет вызвать любую форму конструктора суперкласса.
Для выполнения используеться тот конструктор который соответсвует указаным аргументам
в операторе super()
example shown in class TwoDShapeSuper2
При использовании super() в теле конструктора подкласса то вызываеться конструктор суперкласса от которого
унаследован подкласс содержащий этот оператор. Это анологично работает с многоуровневой-иерархией

ключевое слово super для доступа к членам суперкласса применяется тогда, когда член подкласса
скрывает член суперкласса
это подобно ключевому слову this но super ссылается на член суперкласса данного подкласса
example of keyword super with class members shown in class ASup

Расширенный класс Vehicle с помощью наследование в классе VehicleExt

Многоуровневая иерархия - это возможность Java при которой подкласс может наследоваться
от другого подкласса. Если от класса А наследуеться класс В, а от класса В наследуеться класс C
то класс С наследует все члены класса В и А кроме очевидно закрытых членов этих классов
Пример многоуровневой иерархии показан в расширенном классе TwoDShapeLVL

если в подклассе и суперклассе есть конструктор то выполнение конструкторов начинаеться с первого суперкласса и до
последнего его подкласса. Конструкторы вызываються в порядке наследования классов
пример показан в программе ABConstr

Переменные ссылающиеся на обьект одного типа не могут ссылаться на обьект класса другого типа
однако существует одно исключение:
ссылочной переменной суперкласса может быть присвоенна ссылка на обьект любого подкласса
производного от этого суперкласса. Так выходит что ссылку на обьект суперкласса можно использовать
для обращение к обьектам соответсвующих подклассов
пример показан в классе XvarY

Передача обьекта подкласса конструктору суперкласса показано в классе TwoDShapeOB

Переопределение метода - это когда в суперклассе и в его подклассе находиться метод
с одинаковой сигнатурой. Тогда метод из суперкласса переопределяеться в подклассе
а значит метод подкласса скрывает метод суперкласса.
Для того что бы вызвать метод суперкласса из переопределенного метода суперкласса в подклассе
достаточно использовать в теле метода ключевое слово super и с помощью точечной нотации
вызвать метод суперкласса
Пример показан в классе RedefinMeth

Если методы имеют различную сигнатру то метод из суперкласса не переопределяеться в подклассе
а просто перегружаеться
Пример показан в классе NoRedefinMeth

Механизм переопределения методов лежит в основе Динамической диспетчеризации методов
которая обеспечивает возможность поиска подходящей версии метода во время выполнения программы
а не во время ее компиляции.
Ссылочной переменной суперкласса присваиваеться ссылка на обьект подкласса
И в результате вызова переопределенного метода, вызываеться версия метода
которая переопределенна в подклассе на который ссылается
ссылочна переменная. Выбор переопределенного метода зависит от типа обьекта на который ссылаеться перемення
How it works show in class Sup

В основном переопределение методов нужно для того, что бы в суперклассе определить общие для всех методов
подклассов методы. А в самих подклассах определить конкретные реализации этих методов
это все сочитает в себе полиморфизм - Один интерфейс, множество методов.

Пример демонстрирующий переопределение методов, наследования классов,
массива ссылочных переменных обьектов подклассов
которые в последвии присваиваются суперклассу, и это вполне допустимо так как
сылочной переменной суперкласса можно присвоить ссылки на обьекты подклассов
продемонстрирован в классе TwoDShapes

Абстрактный метод - это метод без тела который определен в абстрактном суперклассе, и он должен быть
переопределен во всех подклассах наследуемых от суперкласса с абстрактным методом
абстрактный метод нельзя обьявить не в абстрактном классе
Возможности обьявить обьект абстрактного класса нет, но остается возможность создания обьектной ссылки
на абстрактный суперкласс.
синтаксис обьявления абстрактного метода:
abstract тип имя (список_параметров);
Подкласс наследуемый от абстрактного суперкласса должен переопределить в себе все абстрактные методы суперкласса

ключевое слово final создано для того что бы запретить переопределение и наследование
пример предотвращения переопределения методов показан в классе FinalMeth
пример предотвращение наследования показано в классе FinalClass

Применяя ключевое слово final к переменным экземпляра создаеться именнованая константа
Такие константы остаеються неизменными и не могут быть изменены на протяжении всего выполнения программы
Таким константам должно быть присвоенно начальное значение
Такие константы могут быть унаследованы подклассами как и другие переменные экземпляра
за исключением закрытых переменных экземпляра(констант)
Пример применения ключевого слова final к переменным экземпляра показан в классе ErrorMsgFinal

Методы класса Object:

Object clone() - Создает новый обьект аналогичиный клонируемому обьекту

boolean equals (Object обьект) - Сравнивает два обьекта, если равнозначны true, иначе false

void finalize () - Вызываеться перед тем как обьект будет удален "Сборщиком мусора"

class<?>getClass() - Определяет класс обьекта во время выполенния

int hashCode() - Возвращает хеш-код, связанный с вызывающим обьектом

void notify() - Возобновляет работу потока, ожидающего уведомления от вызывающего обьекта

void notifyAll() - Возобновляет работу всех потоков, ожидающего уведомления от вызывающего обьекта

String toString() - Возвращает символьную строку описывающую обьект

void wait() - Ожидает исполнения другого потока
void wait(long милисекунды)
void wait(long милисекунды,int наносекунды)

Методы getClass(), notify(), notifyAll(), wait() не могут быть переопределенны в подклассах
в отличии от остальных.

-----------------------------------------------Chapter 8--------------------------------------------------

Пакеты содержит логичски связанные классы. Это полезно при создании больших програм
В каждом пакете свое пространство имен для классов. Классы из разных пакетов могут иметь одинаковые именна

если член класса или класс в пакете обьявлен как public - доступен для любого пакета из любого класса

если член класса обьявлен как privat - то он недоступен в других пакетах так же как и в других классах

если член класса обьявлен как protected - доступен только наследуемым классам из любого пакета
или любым классам в том же пакете где обьявлен данный член класса

пример пакетов и доступа к членам класса в пакетe bookpack

В Java предусмотрена возможность создание интерфейсов с помощью ключевого слова interface
В интерфейсе ни у одного из методов не должно быть тела. По синтаксису это напоминает абстрактные методы
В интерфейсе указывается только что именно должен делать метод но не как это делать
Это означает что в интерфейсе вообще отсутсвует какая либо реализация
каждый метод интерфейса оприори абстрактный
методы обьявленные в интерфейсе неявно обьявлены public

Переменные обьявленные в интерфейсе не являються переменными экземпляра
эти переменные считаються константами и неявно обьявляються как public final static

Как только интерфейс будет определен он может быть реализован в любом количестве классов
А в одном классе может быть реализованно неограниченное количество интерфейсов
если тип доступа интерфейса public - то он доступен в любом другом пакете
отсутствие модификатора доступа говорит о том что интерфейс доступен только в пакете в ктором он обьявлен
Синтаксис интерфейсов выглядит примерно так:

доступ interface имя{
возвращаемый_тип имя_метода_1 (список параметров);
возвращаемый_тип имя_метода_2 (список параметров);
тип переменная_1 = значение;
тип переменная_2 = значение;
//...
возвращаемый_тип имя_метода_N (список параметров);
тип переменная_N = значение;
}

Example:

public inteface Series{
int getNext(); // возвратить следующие по порядку число
void reset(); // сброс
void setStart(int x); // Установить начальное значение
}

для реализации интерфейса в классе следует при инициализации класса следует ввест
ключевое слово implements:
                     Необязательная часть
                              ||
class имя_класса extends имя_суперкласса implements имя_интерфейса{
//...
}

есди класс должен наслдовать несколько интерфейсов то имена интерфейсов следует писать через запятую
класс реализующий интерфейс может содержать дополнительные переменные и методы

пример интерфейса и класса который использует интерфейс в пакете interfaceDemonstrate

Следует так же помнить что если в определении класса имеется ключевое слово implements
но он не реализует все методы указанног интерфейса то он должен быть обьявлен как abstract
создать обьект такого класса не выйдет но он все также может быть суперклассом
а завершить реализацию методов в подклассах

в Java допускается обьявлять переменные хранящие ссылки на интерфейс
Такая переменная может хранить ссылки на обьекты реализующие интерфейс
Следовательно такая переменная не может быть использованна для доступа к обьектам или методам
которые поддерживает обьект но они не обьявленны в интерфейсе
Пример использование ссылочной переменной хранящей ссылку на интерфейс показан в классе SeriesDemo2

Метод parseInt для класса Integer конвертирует строку в целочисленное значение
Конкатенация это процесс склеивания строк. Пример в классе video17

Можно сгенерировать метод toString который будет возвращать все выбранные поля (пкм + Generate + toString())
exmaple in class 24

доделать 8.1.8(ICharQ)

Для того что бы определить набор общедоступных констант достаточно создать интерфейс
в котором обьявлялись бы не методы а только нуные константы. И каждый класс которому
требуються эти константы должен просто реализовать этот интерфейс
Пример такого интерфейса и его использования в пакете consinter

Один интерфейс может наслдеовать другой. Синтаксис такого наследования интерфейсов
ничем не оличаеться от синтаксиса наследования классов
Если класс наследует один интерфейс который наследует другой, то в классе или его подклассах
следует определить все методы обьявленные в интерфейсах по всей цепочке наследования
пример показан в пакете inheritInterface

ключевое слово default используется для того что бы определить метод по умолчанию в интерфейсе
такой метод должен содержать тело, и такой метод не обязательно переопределять в классе
в который имплементирован интерфейс содержащий данный метод
таким образом можно обновлять интерфейсы которые уже используються классами без возможности
повредить код.
Такой метод не обязательно переопределять в классе но все так же это возможно при необходимости
к методам по умолчанию которые не определенны в классе в который имплементрован интерфейс
содержащий данный метод, можно обращаться через обьект класса в который имплементирован интерфейс
при таком обращении в случае если метод по умолчанию не определен в классе
будет использоваться реализация метода уже указанная в интерфейсе
пример обновление интерфейса который уже используеться программой методом по умолчанию
показан в интерфейсе Series
пример ипользования методов по умолчанию в пакете defaultInterfaceDemo

В случае если интерфейс содержит метод по умолчанию
и его наследует интерфейс который так же содержит методот по умолчанию с таким же именем
то при его использовании в классе приоритет будет очевидно у метода в интерфейсе который наследует другой
Если в классе определен данный метод по умолчанию который содержат два интерфейса
то приоритет при использовании будет конечно у метода который переопределен в классе
Если необходимо обратиться из интерфейсе Beta который наследует интрефейс Alpha
к методу из интерфейса Apha, то слeдует использовать данную форму обращение:
Alpha.super.имя_метода

так же в инетрфейсе возможно определять статические методы.
Такие методы не наследуются и не требуют никакой реализации в классе,
и вызывать их нужно используя такую форму:
имя_интерфейса.имя_метода
такой метод должен быть определен в интерфейсе с помощью ключевого слова static и иметь тело
пример такого метода и его использования в пакете defaultInterfaceDemo

Ответы на вопросы к главе 8 в пакете question8chapter

Исключение - это ошибки возникающие в ходе выполнения программы
Есть два подкласса исключение наследуэмых от класса Throwable:
Exception and Error
Error исключения контралировать невозможно так как они возникают в виртуальной
машине Java а не в самой программе
Exception исключение возникают в самой программе
Важным подклассом от класса Exception являеться RuntimeException
который служит для представления различного вида ошибок
которые часто возникают при выполнении программы

Для обработки исключений в java существует 5 ключевых слов
try, catch, throw, throws, finally

Основными средствами поиска исключений являються ключевые слова try/catch
которые используються совместно и их синтаксис таков:
try{
Блок кода в котором отслеживаються ошибки
}
catch(тип исключение_1 обьект исключения){
обработчик исключения тип исключения_1
}
.
.
.
catch(тип исключение_n обьект исключения){
обработчик исключения тип исключения_n
}

в круглые скобки оператора catch помещаеться исключение которое будет перехвачено
напрмер для обработки исключений обусловленных выходом за границы массива используеться:
ArrayindexOutOfBoundsException ехсeption
пример показан в ExcDemo1

так как у оператора try может быть несколько операторов catch
то при возникновение определенного исключение, оператор try передаст управление
оператору catch который способен эту ошибку обработать
если нет операторов catch то программа будет завершенна аварийно
если исключение было обработанно то остальные операторы catch будут проигнорированны
и программа продолжит свое выполнение
программа сама выбирает оператор catch который способен обработать искючение
если такого не будет найденно, то программа все так же аварийно завершит свою работу

для обработки исключений связанных с делением на ноль используеться исключение ArithrneticException
Обработанное исключение удаляеться из системмы и прогрмамма может повторно обрабатывать
возникающие в ней ошибки
пример в классе ExcDemo3

Исключение отслеживаються во всем коде в блоке try.
Это означает что исключение возникающие при вызове метода находящегося в блоке try
могут быть обработаны
пример в классе ExcDemo2

если с оператором try присутвуют несколько операторов catch то выполняеться лишь тот из них
который соответствует типу возникшего исключения
пример демонстрирующий перехват двух исключений в одном блоке try при помощи 2 операторов catch
показан в классе ExcDemo4

С помощью суперкласса Throwable можно перехватывать исключение генерируемое всеми его подклассами
подклассами Throwable являетются классы Error, и Exception. Error являеться суперклассом всех
исключений которые невозможно обрабатывать. А Exception являеться суперклассом всех
исключений которые возникают в самой программе и их можно обрабоать.
Так если потребуеться Перехватить все возможниые исключения в блоке try, можно
использовать один из 2 классов Throwable или Exception.
Если операторов catch несколько то сначала стоит указывать подклассы которые генерируют исключения
а в конце суперклассы которые генерируют все исключения.
пример показан в классе ExcDemo5

Также существуют внутренний блок try и catch соответсвенно
если возникло исключение во внутреннем блоке try и оно не было перехваченно во внутреннем блоке catch
то управление передаеться внешнему оператору catch если он способен обработать исключение
и тогда программа продолжит свое выполнение сразу после внешнего оператора catch
Так если во внутрненнем блоке try есть цикл в котором произошло исключение,
то после передачи выполнения программы внешнему блоку catch выполнение цикла завершиться
Пример показан в классе NestTrys

можно генерировать исключения вручную с помощью оператора throw:
throw new обьект_исключения()
Обьект_исключения - это должен быть обьект класса производного от суперкласса Throwable
пример в классе ThrowDemo

Также можно повторно генерировать исключение в блоке catch для того что бы передать управление
внешнему блоку catch.
Пример показан в классе Rethrow

Методы для обьектов представляющие исключения:

Throwable fillInStackTrace() - Возвращает обьект типа Throwable, содержащий полную
трасировку стека исключений. Этот обьект пригоден для повторного генерирования исключений

String getLocalizedMessage() - Возвращает описание исключение, локализованное
по региональным стандартам

String getMessage() - Возвращает описание исключений

void printStackTrace() - Выводит трассировку стека исключений

void printStackTrace(PrintStream поток) - Выводит трассировку стека исключений в указанный поток

void printStackTrace(PrintWriter поток) - Выводит трассировку стека исключений в указанный поток

String toString() - Возвращает обьект типа String, содержащий полное описание исключения.
Этот метод вызываеться из метода println() при выводе обьекта обьекта типа Throwable.

Применение методов printStackTrace() и toString() показанно в классе ExcTest

Для того что бы определить блок кода после блока try/catch
который будет выполняться абсолютно всегда и не в зависимоти
от того какое условие к этому привело существует ключевое слово finally:
try{
.....
}catch(...){

} finally{
.....
}
пример продемонстрирован в классах UseFinally, FinallyDemo

Для того что бы не обрабатывать исключение в методе в котором они возникли
существует ключевое слово throws:

возвращаемый_тип имя_метода(список_параметров) throws список_исключений{
...Тело метода
}

пример показан в классе ThrowsDemo

Групповой перехват это когда блок catch перехватывает сразу несколько исключений
для этого в параметрах блока catch следует указывать исключение через поразрядное или "|"
Все параметры в блоке catch неявно указываються как final
это можно сделать явно но это совсем не обязательно
Синтаксис блока catch который перехватывает два исключения:

catch(final ArrayIndexOutOfBoundException | ArithmeticException e){
//...
}
Пример показан в классе MultiCatch

Непроверяемые исключение:

ArithmeticExceptio - Арифметическая ошибка, например деление на нуль
ArrayIndexOutOfBoundException - Попытка обращения за границы массива
ArrayStoreException - Попытка ввести в массив элемент, несовместимый с ним по типу
ClassCastException - Недопустимое приведение типов
EnumConstNotPresentException - Попытка использования нумерованного значение, не определенного ранее
IllegalArgumentException - Недопустимый параметр при вызове метода
IllegalMonitorStateException - Недопустимая операция контроля, например, ожидание разблокировки потока
IllegalStateException - Недопустмое состояние среды выполнения или приложения
IllegalThreadsException - Запрашиваемая операция несовместима с текущим состоянием потока
IndexOutOfBoundException - недопустимое значение индекса
NegativeArraySizeException - Создание массива отрицательного размера
NullPointerException - Недопустимое использование пустой ссылки
NumberFormatException - Неверное преобразование символьной строки в число
SecurityException - Попытка нарушить систему защиты
StringIndexOutOfBounds - Попытка обращения к символьной строке за ее границами
TypeNotPresentException - Неизвестный тип
UnsupportedOperationException - Неподдерживаемая операция

Исключения из списка java.lang которые непременно стоит включать в список оператора throws после обьявления метода:

ClassNotFoundException - Класс не найден
CloneNotSupportedException - Попытка клонирования обьекта, не реализующего интерфейс
IllegalAccessException - Доступ к классу зпрещен
InstantiationException - Попытка создания обьекта абстрактного класса или интерфейса
InterruptedException - Прерывание одного потока другим
NoSuchFieldException - Требуемое поле не существует
NoSuchMethodException - Требуемый метод не существует
ReflectiveOperationException - Суперкласс исключений, связанных с рефлексией

Можно самостоятельно создавать исключение для потенциальных ошибок в прикладной программе.
Для этого достаточно создать класс наследуемый от класса Exception который в свою очередб являеться
класом наследуемым от суперкласса Throwable. В создаваемый класс можно не включать реализацию каких
либо методов, так как сам факт его наличия достаточен что бы использовать его в качестве исключения.
Пример показан в классе NonIntResultException, Fixed2Queue, QueueEmptyException, QueueFullException.

